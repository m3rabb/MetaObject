- implement contexts/NameRecs
- figure out how to implement copy for type
- replace {__proto__}, using spawnFrom instead
- change IsArray to   target.constructor === Object
- type function construction
- _super

- add permanent methods

- NOTE: make ALL functions to be considered unique facts EXCEPT ThingWrapped funcs
-- We should make all Krust created func immutable
-- figure out how to make user specifiable func-things, and copy them

- Go back to using parallel hierarchies for instances public/private. This is
  now enable by the mutable write barrier. Whenever a function is added to an
  instance, make sure to enkrust it on the public side

  - Make enkrusted funcs - facts

(typeof target)[1] === "b"

- consider making isIdentical use value vs structure for immutables
- switch back to using typeof instead of constructor

- make type only answer public methods

- make precalculated super methods

- check how outer cache holds values that are created via getters from inner,
  such as with span in List

- Consider making a writerbarrier copy is made NOT copying the causal property

- Add IID to obj before it becomes immutable

- remove _elements from Lists


- parameters are to be treated as a virtual copy!!
- instead of multiple layers of proxies, change the barrierRules as necessary

transport

https://www.slideshare.net/lizza919/types-of-movement-across-the-cell-membrane

passive/active/permeability/diffusion/osmosis/hypotonic/hypertonic/isotonic

active is setting
passive is getting

integument
blubber/flubber


+ consider making things cache the selectors of all set properties.
- consider using rind,pulp,seed architecture instead of krust,outer,inner,core
- reconcile _Blank and _NewCore

+ When a thing is immutable, the outer is immutable but the core is mutable to enable after the fact setting of the iid, and such.

- Streams
+ When making a copy of a id fact, don't copy the id!

+ Consider including outsider immutability confimation recs within the InterMap
  After careful thought, I don't think we need to ensure the vality of immutables
  since an outside can simply set the id of an object to make it a fact which is
  effectively the same as setting it as immutable.


- consider switching to using explicit asMutable instead of immutability barrier in List
- make copying use the same method object tricks as equality uses to avoid expensive bookkeeping actions until necessary

- make global Copy and BeImmutable functions handle id
- consider other copy methods for Lists
- figure a faster way than using AsArray. Add length to Lists

- make comparators consider id in their comparisons of objects.
