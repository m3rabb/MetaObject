- implement contexts/NameRecs
- figure out how to implement copy for type
- replace {__proto__}, using spawnFrom instead
- change IsArray to   target.constructor === Object
- type function construction
- _super

- add permanent methods
- make isImmutable lazy property

- NOTE: make ALL functions to be considered unique facts EXCEPT ThingWrapped funcs
-- We should make all Krust created func immutable
-- figure out how to make user specifiable func-things, and copy them

- Go back to using parallel hierarchies for instances public/private. This is
  now enable by the mutable write barrier. Whenever a function is added to an
  instance, make sure to enkrust it on the public side

  - Make enkrusted funcs - facts

(typeof target)[1] === "b"

- consider making isIdentical use value vs structure for immutables
- switch back to using typeof instead of constructor

- make type only answer public methods

- make precalculated super methods

- check how outer cache holds values that are created via getters from inner,
  such as with span in List

- Consider making a writerbarrier copy is made NOT copying the causal property

- Add IID to obj before it becomes immutable

- remove _elements from Lists


- parameters are to be treated as a virtual copy!!
- instead of multiple layers of proxies, change the barrierRules as necessary

transport

https://www.slideshare.net/lizza919/types-of-movement-across-the-cell-membrane

passive/active/permeability/diffusion/osmosis/hypotonic/hypertonic/isotonic

active is setting
passive is getting

integument
blubber/flubber


- consider making things cache the selectors of all set properties.
- consider using rind,pulp,seed architecture instead of krust,outer,inner,core
- reconcile _Blank and _NewCore

- When a thing is immutable, the outer is immutable but the core is mutable to enable after the fact setting of the iid, and such.

- Streams

- Consider including outsider immutability confimation recs within the InterMap
  After careful thought, I don't think we need to ensure the vality of immutables
  since an outside can simply set the id of an object to make it a fact which is
  effectively the same as setting it as immutable.

InterMap
key               value
Krust             Core
WrappedFunc       CONFIRMED_IMMUTABLE
immutableObj      CONFIRMED_IMMUTABLE
internalCopiedObj CONFIRMED_INTERNALLY_COPIED

IsFactConfiguration = {
  __proto__    : null,
  enumerable   : false,
  writable     : false,
  configurable : false,
  value        : true
}
