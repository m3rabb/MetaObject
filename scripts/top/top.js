// ### JS Hint global pragmas

/* global
  jasmine:false
*/
/* jshint
  maxerr:66, bitwise:true, curly:true, eqeqeq:true, forin:false,
  plusplus:false, noarg:true, nonew:true, latedef:true, regexp:true,
  noempty:false, lastsemic:true, immed:true, expr:true, eqnull:true,
  browser:true, jquery:true, devel:true, globalstrict:true,
  smarttabs:true, trailing:false, newcap:false, undef:true, unused:false
*/
// validthis:true

(function (global) {
  "use strict";

  function factory(require) {

    var RootOf         = Object.getPrototypeOf;
    var SpawnFrom      = Object.create;
    var IsArray        = Array.isArray;
    var Array_join     = Array.prototype.join;
    var Math_floor     = Math.floor;
    var Math_random    = Math.random;
    var DefineProperty = Object.defineProperty;
    var PropertiesOf   = Object.keys;
    var BeImmutable    = Object.freeze;

    var HandleErrorsQuietly = false;

    var ParenthesesMatcher   = /\(|\)/;
    var SelectorMatcher      = /[\w\$_!&]+/gi;
    var VowelMatcher         = /^[aeiou]/i;
    var ValidSelectorMatcher = /_*[a-z][\w$]*/;

    var _Top_root                = SpawnFrom(null);
    var   Stash_root             = SpawnFrom(_Top_root);
    var   _Implementation_root   = SpawnFrom(_Top_root);
    var     _Outer_root          = SpawnFrom(_Implementation_root);
    var       _Ref_root          = SpawnFrom(_Outer_root);
    var     _Inner_root          = SpawnFrom(_Implementation_root);
    var       _Super_root        = SpawnFrom(_Inner_root);
    var       _Base_root         = SpawnFrom(_Inner_root);
    var         Primordial_root  = SpawnFrom(_Base_root);
    var           Nothing_root   = SpawnFrom(Primordial_root);
    var           Thing_root     = SpawnFrom(Primordial_root);
    var             Type_root    = SpawnFrom(Thing_root);

    // var _Default  ----> deal with super called whne there is noe

    // Implementation/Base/Default/Primordial

    var Nothing, Thing, Type, Context, Top;

    function _Implementation () {}
    function _Base () {}
    function _Ref () {}

    _Implementation.prototype = _Implementation_root;
    _Base.prototype           = _Base_root;
    _Ref.prototype            = _Ref_root;




    // #### Random Number Generation
    var RANDOM_MAX = 0xFFFFFFFFFFFF;
    var ZERO_PADDING = "0000000000000000";
    var MAX_UNIQUE_ID_LENGTH =
      (+new Date("2067-01-01") * RANDOM_MAX).toString(36).length;

    function RandomInt(max_min, max_) {
      var min, max;
      if (arguments.length <= 1) {
          min = 0, max = max_min;
      } else {
          min = max_min, max = max_;
      }
      return Math_floor(Math_random() * (max - min + 1)) + min;
    }

    function _NewUniqueId(prefix, seedDate, seedValue) {
      var id, zeros;
      id = seedDate * seedValue;
      id = id.toString(36);
      zeros = ZERO_PADDING.slice(0, MAX_UNIQUE_ID_LENGTH - id.length);
      return prefix + zeros + id;
    }

    function NewUniqueId(prefix_) {
      var prefix = prefix_ || "";
      return _NewUniqueId(prefix, Date.now(), RandomInt(RANDOM_MAX));
    }

    var BASE_KEY = NewUniqueId("BaseKey");
    var REPLACE_BASE_KEY = NewUniqueId("ReplaceBaseKey");


    function NewStash() { return SpawnFrom(Stash_root); }

    function IsUpperCase(target) {
      return target.match && target.match(/^[A-Z]/);
    }

    function IsLowerCase(target) {
      return target.match && target.match(/^[a-z]/);
    }


    function IsValidMethodSelector(selector) {
      return ValidSelectorMatcher.test(selector);
    }

    // function IsAutoGeneratedSelector(selector) {
    //   return selector.indexOf("$") >= 0;
    // }
    //
    // function IsntAutoGeneratedSelector(selector) {
    //   return selector.indexOf("$") < 0;
    // }

    function IsPrivateSelector(selector) {
      return selector[0] === "_";
    }

    function IsPublicSelector(selector) {
      return selector[0] !== "_";
    }


    // function AsMemoizing(FactoryFunc) {
    //   var Repo = NewStash();
    //   return function (id) {
    //     return Repo[id] || (Repo[id] = FactoryFunc.apply(null, arguments));
    //   };
    // }

    // var SelectorMethodFor = AsMemoizing(function NewSelectorMethod(Name) {
    //   return function Selector() { return Name; };
    // });

    function AsMethod_Named(handler, selector) {
      return SetImmutableProperty(handler, "selector", selector);
      //if (handler.Selector) { return handler; }
      // handler.selector = selector SelectorMethodFor(selector);
      // handler.method = Method.newInstance(selector, handler);
      // handler.selector = handler.method.selector;
      // return handler;
    }

    function AsMethod(namedFunction) {
      return AsMethod_Named(namedFunction, namedFunction.name);
    }



    function NewUnimplementedMethod(Selector) {
      return AsMethod_Named(function __Unimplemented(/* arguments */) {
        return this._NoSuchMethod(Selector, arguments);
      }, Selector);
    }

    function NewSuperMethod(Selector) {
      return AsMethod_Named(function __Super(/* arguments */) {  // __super
        var base, baseMethod, target, superMethod;

        base = this.__base;
        baseMethod = base[Selector];
        target = base;

        do {
          target = RootOf(target);
          superMethod = target[Selector];
        } while (superMethod === baseMethod);

        return superMethod ?
          superMethod.apply(base, arguments) :
          base._NoSuchMethod(Selector, arguments);
      }, Selector);
    }


    function NewDelegationMethod(Selector) {
      return AsMethod_Named(function __Delegation(/* arguments */) {  // __delegate
        var target = this.__Base(BASE_KEY);
        var result = target[Selector].apply(target, arguments);
        return (result instanceof _Implementation) ? result.__ref : result;
      }, Selector);
    }

    function ImproperPrivateAccessError() {
      return _SignalError(
        this, "Private method can only be called from within a base object!");
    }

    // function NewImproperPrivateAccessMethod(Selector) {
    //   return function improperPrivateAccessError() {
    //     return SignalError(
    //       this, "Private method #" + Selector +
    //         " can only be called from within a method!");
    //     };
    //   }
    // }

    function NewBaseAccessor(Target) {
      return AsMethod(function __Base(key, newTarget_) {
        if (key === BASE_KEY)         { return Target; }
        if (key === REPLACE_BASE_KEY) { return (Target = newTarget_); }
        return this.privateAccessError();
      });
    }

    // Possibly case __oid to be set when a __ref is made
    // Lazy property installers
    function __ref() {
      // jshint validthis:true
      var ref, _super;
      ref = SpawnFrom(_Ref_root);
      ref.__Base = NewBaseAccessor(this);
      // ref.__ref = ref;
      DefineProperty(this, "__ref", NewStash());
      this.__ref = ref;
      this.__ref_ = ref;
      _super = this._super;
      if (_super) { _super.__ref = ref; }
      return BeImmutable(ref);
    }

    function _super() {
      // jshint validthis:true
      var super_, ref;
      super_ = SpawnFrom(_Super_root);
      super_.__base = this;
      DefineProperty(this, "_super", NewStash());
      this._super = super_;
      ref = this.__ref;
      if (ref) { super_.__ref = ref; }
      return super_;
    }

    // Use Immutable property instead !!!
    // function __oid() {
    //   var oid = NewUniqueId(this.TypeName());
    //   DefineProperty(this, "__oid", NewStash({value: oid}));
    //   return oid;
    // }


    function AddLazyProperty_In(installer, root) {
      var configuration = NewStash({
        writable: true,
        enumerable: false,
        configurable: true,
        get: installer
      });
      DefineProperty(root, installer.name, configuration);
    }

    AddLazyProperty_In(__ref , _Implementation_root);
    AddLazyProperty_In(_super, _Base_root);
    // AddLazyProperty_In(__id  , _Base_root);


    function _SignalError(target, message) {
      var error;

      if (HandleErrorsQuietly) {
        console.warn(message);
      } else {
        console.error(message);
        error = new Error(message);
        error.name = "TopError";
        error.target = target;
        throw error;
      }
      return null;
    }


    function EnsureDefaultMethodsFor(selector) {
      if (_Base_root[selector]) { return; }

      _Base_root[selector]  = NewUnimplementedMethod(selector);
      _Super_root[selector] = NewSuperMethod(selector);
      _Ref_root[selector]   = IsPublicSelector(selector) ?
        NewDelegationMethod(selector) : ImproperPrivateAccessError;
    }

    function Within_At_PutMethod(root, selector, method) {
      EnsureDefaultMethodsFor(selector);
      root[selector] = method;
    }

    function Within_At_Install_(root, selector, baseMethod) {
      var selector$ = selector + "$";
      var method    = AsMethod_Named(baseMethod, selector);
      // var method$   = As$Method_Named(baseMethod, selector$); Handle this !!!

      Within_At_PutMethod(root, selector , method);
      // Within_At_PutMethod(root, selector$, method$);
    }

    function Within_At_Install(root, selector, baseMethod) {
      if (IsValidMethodSelector(selector) &&
          IsntAutoGeneratedSelector(selector)) {
            return  Within_At_Install_(root, selector, baseMethod);
      }
      return _SignalError("Selector must be lowecase and not end with $!");
    }


    Within_At_Install_(_Super_root, "__Base", function __Base(key) {
      return this.__base;
    });

    Within_At_Install_(_Base_root, "__Base", function __Base(key) {
      return this;
    });

    Within_At_Install_(_Base_root, "_NoSuchMethod",
     function _NoSuchMethod(selector, args) {
      return _SignalError(this, "Receiver has no such method #"+ selector +"!");
    });


    Within_At_PutMethod(_Base_root, "IsIdentical", function IsIdentical(that) {
      // return that.__Base ? (this.__ref_ === that) : (this === that);
      return that instanceof _Ref ? (this.__ref_ === that) : (this === that);
    });

    Within_At_PutMethod(_Ref_root, "IsIdentical", function IsIdentical(that) {
      return that instanceof _Base ? (this === that.__ref_) : (this === that);
    });




    Within_At_Install_(Thing_root, "At_PutMethod",
     function At_PutMethod(selector, method) {
      if (this.IsLocked()) { return this.LockedObjectError(); }
      Within_At_Install(this, selector, method);
      return this;
    });

    function CreatePureGetter(Value) {
      return function () { return Value; };
    }


    // Minimum metahierarchy methods

    Thing_root.At_PutMethod("AddMethod", function AddMethod(/* arguments */) {
      var index = -1;
      var count = arguments.length;
      var method;

      while (++index < count) {
        method = AsMethod(arguments[index]);
        this.At_PutMethod(method.selector, method);
      }
      return this;
    });

    Thing_root.AddMethod(function AddAlias(alias, original) {
      return this.At_PutMethod(alias, this[original]);
    });

    Thing_root.AddMethod(function _Init(name_) {
      // this._super._Init(arguments);
      if (name_ !== undefined) { this._Name = name_; }
      return this;
    });

    Thing_root.AddMethod(function Extend(extensionAction) {
      // jshint validthis:true
      var receiver, ref, base;
      if (extensionAction == null) { return this; }
      if (extensionAction.length) {
        ref = this.__ref;
        if (this.__isLocked) {
          receiver = ref;
          base = null;
        } else {
          receiver = base = this;
        }
        extensionAction.call(receiver, ref, base);
      } else {
        receiver = this.__isLocked ? this.__ref : this;
        extensionAction.call(receiver);
      }
      return this;
    });

    var ConnectSubtype_ToSupertype;

    Type_root.AddMethod(function _Init(name, supertype, instanceRoot) {
      this._super._Init(name);
      this._subtypes = NewStash();
      ConnectSubtype_ToSupertype(this, supertype);
      this._instanceRoot = instanceRoot;
      instanceRoot.At_PutMethod("Type", CreatePureGetter(this));
    });

    Type_root.AddMethod(function New(/* arguments */) {
      var instanceRoot = this._instanceRoot;
      var instance = SpawnFrom(instanceRoot);
      instanceRoot._Init.apply(instance, arguments);
      return instanceRoot;
    });

    Type_root.AddMethod(function AddInstanceMethod(namedFunction) {
      if (this.IsLocked()) { return this.LockedObjectError(); }
      this._instanceRoot.AddMethod(namedFunction);
      return this;
    });

    Type_root.AddAlias("AddIMethod", "AddInstanceMethod");

    Type_root.AddMethod(function AddInstanceAlias(alias, original) {
      if (this.IsLocked()) { return this.LockedObjectError(); }
      this._instanceRoot.AddAlias(alias, original);
      return this;
    });

    Type_root.AddAlias("AddIAlias", "AddInstanceAlias");


    (function Bootstrap_Core_Types() {
      ConnectSubtype_ToSupertype = function (_subtype, supertype) {
        _subtype._supertype = supertype;
      };

      Type_root._instanceRoot = Type_root;
      Type    = Type_root.New("Type"   , Thing, Type_root );

      Nothing = Type_root.New("Nothing", null , Nothing_root);
      Thing   = Type_root.New("Thing"  , null , Thing_root);
      // delete Type_root._instanceRoot;

      ConnectSubtype_ToSupertype = function (_subtype, supertype) {
        var _supertype = _supertype.__Base(BASE_KEY);
        _subtype._supertype = supertype;
        _supertype._subtypes[_subtype.__oid] = _subtype;
      };
    })();

    Thing.Extend(function () {
      this.AddIMethod(function IsLocked() { return this.__isLocked || false; });

      this.AddIMethod(function Lock()     { this.__isLocked = true; return this; });

      this.AddIMethod(function Yourself() { return this; });

      this.AddIMethod(function Name()     { return this._name; });

      this.AddIMethod(function TypeName() { return this.Type()._name; });

      this.AddIMethod(function Id()       { return this.__id; });

      this.AddIMethod(function ToString() {
        var name = this.Name() || "";
        var typeName = this.TypeName();
        var prefix = typeName.match(VowelMatcher) ? "an " : "a ";
        return name !== undefined ?
          typeName + ":" + name : prefix + typeName;
      });

      this.AddIMethod(function Print() {
        return this.ToString();
      });

      this.AddIMethod(function SignalError(/* arguments */) {
        var message = Array_join(arguments, "");
        _SignalError(this, message);
        return this;
      });

      this.AddIMethod(function _NoSuchMethod(selector, args) {
        var message = this.Print() + " has no such method #" + selector + "!";
        return this.SignalError(message);
      });

      this.AddIMethod(function LockProperty(name) {
        DefineProperty(this, name, LockedConfiguration);
        return this;
      });

      this.AddIMethod(function LockedObjectError() {
        return this.SignalError("Attempt to modify locked object!");
      });

      this.AddIMethod(function IsSame(that) {
        return this.Id() === that.Id();
      });

      this.AddIMethod(function IsEqual(that) {
        return this.IsIdentical(that);
      });

      this.AddIMethod(function KnownProperties(names_) {
        return arguments.length ?
          (this._knownProperties = names_.slice().sort(), this) :
          (this._knownProperties || []);
      });

      this.AddIMethod(function KnowProperty(name) {
        var names = this._knownProperties || (this._knownProperties = []);
        var index = names.length;
        while (index--) {
          if (names[index] === name) { return this; }
        }
        names.push(name);
        names.sort();
        return this;
      });

      this.AddIMethod(function UnknowProperty(name) {
        var names, index;
        if ((names = this._knownProperties)) {
          index = names.length;
          while (index--) {
            if (names[index] === name) {
              names.splice(index, 1);
              break;
            }
          }
        }
        return this;
      });

      this.AddIMethod(function ShallowCopy() {
        var copy, names, index, name;
        copy = this.Type().New();
        names = this._knownProperties;
        index = names.length;
        if (names) {
          while (index--) {
            name = names[index];
            copy[name] = this[name];
          }
        }
        return copy;
      });

      this.AddIMethod(function Copy() {
        return this.ShallowCopy();
      });

    });


    Type.Extend(function () {
      this.AddMethod(function New(name, supertype_extend_, extend_) {
        var supertype, extensionAction, instanceRoot, type;

        if (IsLowerCase(name)) {
          return this.signalError("Type must have an uppercase name!");
        }
        if (typeof supertype_extend_ === "object") {
          supertype = supertype_extend_;
          extensionAction = extend_;
        } else {
          supertype = Thing;
          extensionAction = supertype_extend_;
        }

        instanceRoot = SpawnFrom(supertype._instanceRoot);
        type = this._super.New(name, supertype, instanceRoot);
        return type.Extend(extensionAction);
      });


      this.AddIMethod(function NewSubtype(name, extend_) {
        return Type.New(name, this, extend_);
      });

      this.AddIMethod(function Supertype() {
        return this._supertype;
      });

      this.AddIMethod(function Subtypes() {
        var subtypes, index, list, oid;

        subtypes = this._subtypes;
        index = 0;
        list = [];

        for (oid in subtypes) {
          list[index++] = subtypes[oid];
        }
        return list.sort();
      });

      this.AddIMethod(function InstanceMethodAt(selector) {
        return this._instanceRoot[selector];
      });

      this.AddIAlias("IMethodAt", "InstanceMethodAt");


      this.AddIMethod(function KnownInstanceProperties(names_) {
        return (arguments.length) ?
          this._instanceRoot.KnownProperties(names_) :
          this._instanceRoot.KnownProperties();
      });

      this.AddIAlias("KnownIProperties", "KnownInstanceProperties");

    });

    function As$Name(name) {
      return (name[0] === "$") ? name : "$" + name;
    }

    Context = Type.New("Context", function () {
      this.AddIMethod(function New(name, supercontext_) {
        if (IsLowerCase(name)) {
          return this.signalError("Context must have an uppercase name!");
        }
        var supercontext = supercontext_ || null;
        if (supercontext && supercontext[As$Name(name)]) {
          return this.signalError("Super context already contains name!");
        }
        var root = (supercontext === global) ? null : supercontext;
        var instance = SpawnFrom(root || this._instanceRoot);
        return instance._Init(name, supercontext, root);
      });

      this.AddIMethod(function _Init(name, supercontext, supercontext_) {
        this._super._Init(name);
        this._subcontexts = [];
        this._supercontext = supercontext;
        this.AddProperty(name, this);
        if (supercontext_) {
          var subcontexts = supercontext_._subcontexts;
          subcontexts.push(this);
          subcontexts.sort();
        }
      });

      this.AddIMethod(function Supercontext() { return this._supercontext; });

      this.AddIMethod(function Subcontexts() {
        return this._subcontexts.slice();
      });

      this.AddIMethod(function Lock() {
        if (this.IsLocked()) { return this; }
        return this.PropertiesDo(this.LockProperty);
        // return this._super.Lock();
      });

      this.AddIMethod(function PropertiesDo(action) {
        var name, names, index;
        names = PropertiesOf(this);
        index = names.length;
        while (index--) {
          name = names[index];
          if (name[0] === "$") {
            action.call(this, name, this[name]);
          }
        }
        return this;
      });

      this.AddIMethod(function AddProperty(name, value) {
        var $name = As$Name(name);
        if (IsLowerCase) {
          return this.SignalError("Property name ", name, " must be uppercase!");
        }
        if (this.IsLocked()) {
          if (this[$name]) {
            return this.SignalError("Cannot overwrite locked property: ", $name, " !");
          }
          this[$name] = value;
          return this.LockProperty($name);
        }
        this[$name] = value;
        return this;
      });

      this.AddIMethod(function Add(/* arguments */) {
        var index, count, namedObject;
        index = -1;
        count = arguments.length;
        while (++index < count) {
          namedObject = arguments[index];
          this.AddProperty(namedObject.Name(), namedObject);
        }
        return this;
      });

      this.AddIMethod(function SetType(name, supertype_extend_, extend_) {
        var supertype, extensionAction, type;

        switch (typeof supertype_extend_) {
          case "string" :
            supertype = this[As$Name(supertype_extend_)];
            extensionAction = extend_;
            if (supertype == null) {
              this.SignalError("Can't find supertype: ", supertype_extend_, "!");
              return null;
            }
            break;
          case "object" :
            supertype = supertype_extend_;
            extensionAction = extend_;
            break;
          case "function" :
            extensionAction = supertype_extend_;
            break;
        }

        if ((type = this[As$Name(name)])) {
          if (supertype && supertype !== type._supertype) {
            this.SignalError("Type ", name, " exists with different supertype!");
            return null;
          }
        } else {
          type = Type.New(name, supertype);
          this.Add(type);
        }
        return type.Extend(extensionAction);
      });

      this.AddIMethod(function SetSubcontext(name, extend_) {
        return Context.New(name, this).Extend(extend_);
      });
    });

    return Context.New("Top", function () {
      this.Add(Thing, Nothing, Type, Context);
      this.AddMethod(NewStash, RootOf, SpawnFrom);
      this.AddMethod(IsArray, IsUpperCase);

      this.AddMethod(function IsRef(target) {
        return target instanceof _Ref;
      });

      this.AddMethod(function IsBase(target) {
        return target instanceof _Base;
      });
    });
  }

  if (typeof define === 'function' && define.amd) {
      // AMD. Register as an anonymous module.
      define(factory);
  } else {
      // Browser globals
      global.Top = factory(global);
  }
})(this);



  // function ExecuteOn(method, receiver, arg1, arg2, arg3, allArgs) {
  //   switch (allArgs.length) {
  //     case 0 : return method.call(receiver);
  //     case 1 : return method.call(receiver, arg1);
  //     case 2 : return method.call(receiver, arg1, arg2);
  //     case 3 : return method.call(receiver, arg1, arg2, arg3);
  //   }
  //   var remainingArgs = Array_slice.call(allArgs, 1);
  //   return method.apply(receiver, remainingArgs);
  // }


  // Thing_root.addMethod(function perform(selector, arg_, arg__, arg___) {
  //   return ExecuteOn(this[selector], this, arg_, arg__, arg___, arguments);
  // });
  //
  // Thing_root.addMethod(function performWithArgs(selector, args) {
  //   return this[selector].apply(this, args);
  // });


  // Context.AddInstanceMethod(function At_IfPresent_IfAbsent(name, present, absent) {
  //   var $name = As$Name(name);
  //   var value = this[$name];
  //   return value ? present.call(this, value, $name) : absent.call(this, $name);
  // });
