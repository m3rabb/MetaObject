// ### JS Hint global pragmas

/* global
  jasmine:false
*/
/* jshint
  maxerr:66, bitwise:true, curly:true, eqeqeq:true, forin:true,
  plusplus:false, noarg:true, nonew:true, latedef:true, regexp:true,
  noempty:false, lastsemic:true, immed:true, expr:true,
  browser:true, jquery:true, devel:true, globalstrict:true,
  smarttabs:true, trailing:false, newcap:false, undef:true, unused:false
*/
// validthis:true

(function (global) {
  "use strict";

  function factory(require) {

    var RootOf         = Object.getPrototypeOf;
    var SpawnFrom      = Object.create;
    var IsArray        = Array.isArray;
    var Array_join     = Array.prototype.join;
    var Math_floor     = Math.floor;
    var Math_random    = Math.random;
    var DefineProperty = Object.defineProperty;
    var PropertiesOf   = Object.keys;
    var BeImmutable    = Object.freeze;

    var HandleErrorsQuietly = false;

    var ParenthesesMatcher = /\(|\)/;
    var SelectorMatcher    = /[\w\$_!&]+/gi;
    var VowelMatcher       = /^[aeiou]/i;

    var _Top_root              = SpawnFrom(null);
    var   Stash_root           = SpawnFrom(_Top_root);
    var   _Ref_root            = SpawnFrom(_Top_root);
    // var _Default  ----> deal with super called whne there is noe
    var   _Implementation_root = SpawnFrom(_Top_root);
    var     _Super_root        = SpawnFrom(_Implementation_root);
    var     _Base_root         = SpawnFrom(_Implementation_root);
    var       Primordial_root  = SpawnFrom(_Base_root);
    var         Nothing_root   = SpawnFrom(Primordial_root);
    var         Thing_root     = SpawnFrom(Primordial_root);
    var           Type_root    = SpawnFrom(Thing_root);

    // Implementation/Base/Default/Primordial

    var Thing, Type, Context, Top;


    function NewStash() { return SpawnFrom(Stash_root); }

    function IsUpperCase(target) {
      return target.match && target.match(/^[A-Z]/);
    }

    function IsLowerCase(target) {
      return target.match && target.match(/^[a-z]/);
    }

    VALID_SELECTOR_MATCHER = /_*[a-z][\w$]*/;

    function IsValidMethodSelector(selector) {
      return VALID_SELECTOR_MATCHER.test(selector);
    }

    function IsAutoGeneratedSelector(selector) {
      return selector.indexOf("$") >= 0;
    }

    function IsntAutoGeneratedSelector(selector) {
      return selector.indexOf("$") < 0;
    }

    function IsPrivateSelector(selector) {
      return selector[0] === "_";
    }

    function IsPublicSelector(selector) {
      return selector[0] !== "_";
    }


    function AsMemoizing(FactoryFunc) {
      var Repo = NewStash();
      return function (id) {
        return Repo[id] || (Repo[id] = FactoryFunc.apply(null, arguments));
      }
    }

    var SelectorMethodFor = AsMemoizing(function NewSelectorMethod(Name) {
      return function Selector() { return Name; }
    });

    function AsMethod_Named(handler, selector) {
      if (handler.Selector) { return handler; }
      handler.Selector = SelectorMethodFor(selector);
      // handler.method = Method.newInstance(selector, handler);
      // handler.selector = handler.method.selector;
      return handler;
    }

    function AsMethod(namedFunction) {
      return AsMethod_Named(namedFunction, namedFunction.name);
    }



    function NewUnimplementedMethod(Selector) {
      return AsMethod_Named(function __Unimplemented(/* arguments */) {
        return this._NoSuchMethod(Selector, arguments);
      }, Selector);
    }

    function NewSuperMethod(Selector) {
      return AsMethod_Named(function __Super(/* arguments */) {  // __super
        var self, baseMethod, target, superMethod;

        self = this.__self;
        baseMethod = self[Selector];
        target = self;

        do {
          target = RootOf(target);
          superMethod = target[Selector];
        } while (superMethod === baseMethod);

        return superMethod ?
          superMethod.apply(self, arguments) :
          self._NoSuchMethod(Selector, arguments);
      }, Selector);
    }


    function NewDelegationMethod(Selector) {
      return AsMethod_Named(function __Delegation(/* arguments */) {  // __delegate
        var target = this.__Self(INNER_KEY);
        var result = target[Selector].apply(target, arguments);
        return (result instanceof Implementation) ? result.__ref : result;
      }, Selector);
    }

    function ImproperPrivateAccessError() {
      return SignalError(
        this, "Private method can only be called from within a base object!");
      };
    }

    // function NewImproperPrivateAccessMethod(Selector) {
    //   return function improperPrivateAccessError() {
    //     return SignalError(
    //       this, "Private method #" + Selector +
    //         " can only be called from within a method!");
    //     };
    //   }
    // }

    function NewSelfAccessor(Target) {
      return AsMethod(function __Self(key, newTarget_) {
        if (key === INNER_KEY)         { return Target; }
        if (key === REPLACE_INNER_KEY) { return (Target = newTarget_); }
        return this.privateAccessError();
      });
    });

    // Lazy property installers
    function __ref() {
      var ref, _super;
      ref = SpawnFrom(_Ref_root);
      ref.__Self = NewSelfAccessor(this);
      DefineProperty(this, "__ref", NewStash());
      this.__ref = ref;
      _super = this._super;
      if (_super) { _super.__ref = ref; }
      return BeImmutable(ref);
    }

    function _super() {
      var _super, ref;
      _super = SpawnFrom(_Super_root);
      _super.__self = this;
      DefineProperty(this, "_super", NewStash());
      this._super = _super;
      ref = this.__ref;
      if (ref) { _super.__ref = ref; }
      return _super;
    }

    function __oid() {
      var oid = NewUniqueId(this.TypeName());
      DefineProperty(this, "__id", NewStash({value: oid}));
      return oid;
    }


    function AddLazyProperty_In(installer, root) {
      var configuration = NewStash({
        writable: true,
        enumerable: false,
        configurable: true,
        get: installer
      });
      DefineProperty(root, installer.name, configuration);
    }

    AddLazyProperty_In(__ref , _Implementation_root);
    AddLazyProperty_In(_super, _Base_root);
    AddLazyProperty_In(__id  , _Base_root);


    function _SignalError(target, message) {
      var error;

      if (HandleErrorsQuietly) {
        console.warn(message);
      } else {
        console.error(message);
        error = new Error(message);
        error.name = "TopError";
        error.target = target;
        throw error;
      }
      return null;
    }


    function EnsureDefaultMethodsFor(selector) {
      if (_Base_root[selector]) { return; }

      _Base_root[selector]  = NewUnimplementedMethod(selector);
      _Super_root[selector] = NewSuperMethod(selector);
      _Ref_root[selector]   = IsPublicSelector(selector) ?
        NewDelegationMethod(selector) : ImproperPrivateAccessError;
    }

    function Within_At_PutMethod(root, selector, method) {
      EnsureDefaultMethodsFor(selector);
      root[selector] = method;
    }

    function Within_At_Install_(root, selector, baseMethod) {
      var selector$ = selector + "$";
      var method    = AsMethod_Named(baseMethod, selector);
      var method$   = As$Method_Named(baseMethod, selector$);

      Within_At_PutMethod(root, selector , method);
      Within_At_PutMethod(root, selector$, method$);
    }

    function Within_At_Install(root, selector, baseMethod) {
      if (IsValidMethodSelector(selector) &&
          IsntAutoGeneratedSelector(selector)) {
            return  Within_At_Install_(root, selector, baseMethod);
      }
      return _SignalError("Selector must be lowecase and not end with $!");
    }


    Within_At_Install_(_Base_root, "_NoSuchMethod",
     function _NoSuchMethod(selector, args) {
      return _SignalError(this, "Receiver has no such method #"+ selector +"!");
    });

    Within_At_Install_(Thing_root, "At_PutMethod",
     function At_PutMethod(selector, method) {
      if (this.IsLocked()) { return this.LockedObjectError(); }
      Within_At_Install(this, selector, method);
      return this;
    });


    Thing_root.At_PutMethod("AddMethod", function AddMethod(namedFunction) {
      return this.At_PutMethod(namedFunction.name, namedFunction);
    });

    Thing_root.AddMethod(function AddAlias(alias, original) {
      var method = this[original];
      return this.At_PutMethod(alias, method);
    });


    Thing_root.AddMethod(function IsLocked() { return this.__isLocked || false; });

    Thing_root.AddMethod(function Lock() { return this.__isLocked = true; });

    Thing_root.AddMethod(function Yourself() { return this; });

    Thing_root.AddMethod(function Name() { return this._name; });

    Thing_root.AddMethod(function TypeName() { return this.Type()._name; });

    Thing_root.AddMethod(function Id() { return this.__id; });

    Thing_root.AddMethod(function ToString() {
      var name = this.Name();
      var typeName = this.Type().Name();
      var prefix = typeName.match(VowelMatcher) ? "an " : "a ";
      return name !== undefined ?
        typeName + ":" + name : prefix + typeName;
    });

    Thing_root.AddMethod(function Print() {
      return this.ToString();
    });

    Thing_root.AddMethod(function SignalError(/* arguments */) {
      var message = Array_join(arguments, "");
      _SignalError(this, message);
      return this;
    });

    Thing_root.AddMethod(function _NoSuchMethod(selector, args) {
      var message = this.Print() + " has no such method #" + selector + "!";
      return this.SignalError(message);
    });

    Thing_root.AddMethod(function LockProperty(name) {
      DefineProperty(this, name, LockedConfiguration);
      return this;
    });

    Thing_root.AddMethod(function LockedObjectError() {
      return this.SignalError("Attempt to modify locked object!");
    });

    Thing_root.AddMethod(function _Init(name_) {
      // this._super._Init(arguments);
      if (name_ !== undefined) { this._Name = name_; }
      return this;
    });

    Thing_root.AddMethod(function Extend(extensionAction) {
      var isLocked, receiver, ref, base;
      if (extensionAction == null) { return this; }
      if (extensionAction.length) {
        ref = this.__ref;
        if (this.IsLocked()) {
          receiver = ref;
          base = null;
        } else {
          receiver = base = this;
        }
        extensionAction.call(receiver, ref : base);
      } else {
        extensionAction.call(this.IsLocked() ? this.__ref, this);
      }
      return this;
    });


    /// !!! IsSame
    /// IsIdentical
    /// IsEqual
    /// Equals



    function CreatePureGetter(Value) {z
      return function () { return Value; };
    }


    Type_root.AddMethod(function New(/* arguments */) {
      var instanceRoot = this._instanceRoot;
      var instance = SpawnFrom(instanceRoot);
      instanceRoot._Init.apply(instance, arguments);
      return instanceRoot;
    });

    Type_root.AddMethod(function _Init(name, supertype, instanceRoot) {
      this._super._Init(name);
      this._subtypes = NewStash();
      ConnectSubtype_ToSupertype(this, supertype);
      this._instanceRoot = instanceRoot;
      instanceRoot.At_PutMethod("Type", CreatePureGetter(this));
    });


    Type_root.AddMethod(function Supertype() {
      return this._supertype;
    });

    Type_root.AddMethod(function Subtypes() {
      return PropertiesOf(this._subtypes);
    });

    Type_root.AddMethod(function AddInstanceMethod(namedFunction) {
      if (this.IsLocked()) { return this.LockedObjectError(); }
      this._instanceRoot.AddMethod(namedFunction);
      return this;
    });

    Type_root.AddMethod(function NewSubtype(name, extend_) {
      return Type.New(name, this, extend_);
    });




    (function Metahierarchy_Bootstrap() {
      ConnectSubtype_ToSupertype = function (subtype, supertype) {
        subtype._supertype = supertype;
      };

      Type_root._instanceRoot = Type_root;
      Type    = Type_root.New("Type"   , Thing, Type_root );

      Nothing = Type_root.New("Nothing", null , Nothing_root);
      Thing   = Type_root.New("Thing"  , null , Thing_root);
      // delete Type_root._instanceRoot;

      ConnectSubtype_ToSupertype = function (subtype, supertype) {
        subtype._supertype = supertype;
        supertype._subtypes[subtype.__Id] = subtype;
      };
    })();



    Type.AddMethod(function New(name, supertype_extend_, extend_) {
      var supertype, extensionAction, instanceRoot, type;
      if (IsLowerCase(name)) {
        return this.signalError("Type must have an uppercase name!");
      }
      if (typeof supertype_extend_ === "object") {
        superType = supertype_extend_;
        extensionAction = extend_;
      else {
        supertype = Thing;
        extensionAction = supertype_extend_;
      }
      instanceRoot = SpawnFrom(supertype._instanceRoot);
      type = this._super.New(name, supertype, instanceRoot);
      return type.Extend(extensionAction);
    });










    Context = Type.New("Context");

    Context.AddMethod(function New(name, superContext_) {
      if (IsLowerCase(name)) {
        return this.signalError("Context must have an uppercase name!");
      }
      var superContext = superContext_ || null;
      var root = (superContext_ === global) ? null : superContext_;
      var instance = SpawnFrom(root || this._instanceRoot);
      return instance._Init(name, superContext);
    });

    Context.AddInstanceMethod(function _Init(name, superContext) {
      this._super._Init(name);
      this._subcontexts = NewStash();
      if (superContext) {
        supercontext._subcontexts[subcontext._name] = this;
      }
    });

    Context.AddInstanceMethod(function PropertiesDo(action) {
      var name, names, index;
      names = PropertiesOf(this);
      index = names.length;
      while (index--) {
        name = names[index];
        if (name[0] === "$") {
          action.call(this, name, this[name]);
        }
      }
      return this;
    });

    Context.AddInstanceMethod(function Lock() {
      if (this.IsLocked()) { return this; }
      return this.PropertiesDo(this.LockProperty);
    });



    function As$Name(name) {
      return (name[0] === "$") ? name : "$" + name;
    }

    Context.AddInstanceMethod(function AddProperty(name, value) {
      var $name = As$Name(name);
      if (IsLowerCase) {
        return this.SignalError("Property name ", name, " must be uppercase!");
      }
      if (this.IsLocked()) {
        if (this[$name]) {
          return this.SignalError("Cannot overwrite locked property: ", $name, " !");
        }
        this[$name] = value;
        return this.LockProperty($name);
      }
      this[$name] = value;
      return this;
    });

    Context.AddInstanceMethod(function Add(namedObject) {
      return this.AddProperty(namedObject.Name(), namedObject);
    });

    Context.AddInstanceMethod(function SetType(name, supertype_extend_, extend_) {
      var supertype, extensionAction, type;

      switch (typeof supertype_extend_) {
        case "string" :
          supertype = this[As$Name(supertype_extend_)];
          extensionAction = extend_;
          if (supertype == undefined) {
            this.SignalError("Can't find supertype: ", supertype_extend_, "!");
            return null;
          }
          break;
        case "object" :
          supertype = supertype_extend_;
          extensionAction = extend_;
          break;
        case "function" :
          extensionAction = supertype_extend_;
          break;
      }

      if ((type = this[As$Name(name)])) {
        if (supertype && supertype !== type._supertype) {
          this.SignalError("Type ", name, " exists with different supertype!");
        }
      } else {
        type = Type.New(name, supertype, extensionAction);
        this.Add(type);
      }
      return type;
    });

    Context.AddInstanceMethod(function SetSubcontext(name, extend_) {
      /// !!!
    });

    Top.AddMethod(function IsRef);

    Top.AddMethod(function IsBase);


    Top = Context.newInstance("Top");

    Top.Thing       = Thing;
    Top.Type        = Type;
    Top.Context     = Context;

    Top.newStash    = NewStash;
    Top.rootOf      = RootOf;
    Top.spawnFrom   = SpawnFrom;

    Top.isArray     = IsArray;
    Top.isUpperCase = IsUpperCase;
    Top.asMemoizing = AsMemoizing;

    return Top;
  }

  if (typeof define === 'function' && define.amd) {
      // AMD. Register as an anonymous module.
      define(factory);
  } else {
      // Browser globals
      global.Top = factory(global);
  }
})(this);



  // function ExecuteOn(method, receiver, arg1, arg2, arg3, allArgs) {
  //   switch (allArgs.length) {
  //     case 0 : return method.call(receiver);
  //     case 1 : return method.call(receiver, arg1);
  //     case 2 : return method.call(receiver, arg1, arg2);
  //     case 3 : return method.call(receiver, arg1, arg2, arg3);
  //   }
  //   var remainingArgs = Array_slice.call(allArgs, 1);
  //   return method.apply(receiver, remainingArgs);
  // }


  // Thing_root.addMethod(function perform(selector, arg_, arg__, arg___) {
  //   return ExecuteOn(this[selector], this, arg_, arg__, arg___, arguments);
  // });
  //
  // Thing_root.addMethod(function performWithArgs(selector, args) {
  //   return this[selector].apply(this, args);
  // });


  // Context.AddInstanceMethod(function At_IfPresent_IfAbsent(name, present, absent) {
  //   var $name = As$Name(name);
  //   var value = this[$name];
  //   return value ? present.call(this, value, $name) : absent.call(this, $name);
  // });
