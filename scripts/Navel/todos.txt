- implement contexts/NameRecs
- figure out how to implement copy for type
- replace {__proto__}, using spawnFrom instead
- change IsArray to   target.constructor === Object
- type function construction
- _super

- add permanent methods

- NOTE: make ALL functions to be considered unique facts EXCEPT ThingWrapped funcs
-- We should make all Krust created func immutable
-- figure out how to make user specifiable func-things, and copy them

- Go back to using parallel hierarchies for instances public/private. This is
  now enable by the mutable write barrier. Whenever a function is added to an
  instance, make sure to enkrust it on the public side

  - Make enkrusted funcs - facts

(typeof target)[1] === "b"

- consider making isIdentical use value vs structure for immutables
- switch back to using typeof instead of constructor

- make type only answer public methods

- make precalculated super methods

- check how outer cache holds values that are created via getters from inner,
  such as with span in List

- Consider making a writerbarrier copy is made NOT copying the causal property

- Add IID to obj before it becomes immutable

- remove _elements from Lists


- parameters are to be treated as a virtual copy!!
- instead of multiple layers of proxies, change the barrierRules as necessary

transport

https://www.slideshare.net/lizza919/types-of-movement-across-the-cell-membrane

passive/active/permeability/diffusion/osmosis/hypotonic/hypertonic/isotonic

active is setting
passive is getting

integument
blubber/flubber


+ consider making things cache the selectors of all set properties.
- consider using rind,pulp,seed architecture instead of krust,outer,inner,core
- reconcile _Blank and _NewCore

+ When a thing is immutable, the outer is immutable but the core is mutable to enable after the fact setting of the iid, and such.

- Streams
+ When making a copy of a id fact, don't copy the id!

+ Consider including outsider immutability confimation recs within the InterMap
  After careful thought, I don't think we need to ensure the vality of immutables
  since an outside can simply set the id of an object to make it a fact which is
  effectively the same as setting it as immutable.


- consider switching to using explicit asMutable instead of immutability barrier in List
- make copying use the same method object tricks as equality uses to avoid expensive bookkeeping actions until necessary

- make global Copy and BeImmutable functions handle id
- consider other copy methods for Lists
- figure a faster way than using AsArray. Add length to Lists

- make comparators consider id in their comparisons of objects.

+ consider dumping RIND and only using $ instead. NOPE

== NOTE: The discussion below is moot. See below
The challenge with JS immutability is that it forces all properties to be visible with hasOwn. I see three way to handle this:
1) don't use JS immutability at all and handle it myself. The disadvantage is that its possible that the JS engine speeds up immutable objects and I would loose that improvement.  The advantage is that outers could use their own INNER ref that would avoid the call to InterMap.get and speed up public method calls.
2) separate the outer object into two parts one that inherits from the other. When needed to be immutable, the child part would be made immutable, and the parent part would be left mutable and would contain the INNER ref.
3) split the baby, and when mutable, have the outer have a ref to INNER, but when made immutable remove the INNER ref, and only use a $ ref within the outer.  The Base$outer$root would hold a default INNER ref set to null to prevent error in the BaseBehavior and help distinguish the immutable from mutable.
4) never have an INNER ref within the outer, and only use the slower InterMap tunnel to access INNER.
XX) I must use #4 because using INNER is a security risk, if a proxied villain hijacks one of the methods and calls it on itself and discovers the INNER selector, and then reuses it on a valid thing to steal its secrets.


==
keep track of "volatiles", getter properties that should be copied as getters,
as opposed to as values. keep track of lazy values, that should be copied at all

==
only copyable properties should be visible

==
Add object level properties and methods



==
Make immutable copy on demand work from calls to this as well!!!
==
Consider making all public methods answer facts

==
Consider not allowing anything to be set to undefined as an implementation sentinel

==
ensure symbols arent "has-able" thru proxies

change _subtypes and _supertypes to be subtypes and supertypes after implementing CopyObject
