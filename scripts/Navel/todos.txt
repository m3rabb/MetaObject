- implement contexts/NameRecs
- figure out how to implement copy for type
- change IsArray to   target.constructor === Object
- type function construction
- _super

- add permanent methods

- NOTE: make ALL functions to be considered unique facts EXCEPT ThingWrapped funcs
-- We should make all Krust created func immutable
-- figure out how to make user specifiable func-things, and copy them


(typeof target)[1] === "b"

- consider making isIdentical use value vs structure for immutables
- switch back to using typeof instead of constructor


- check how outer cache holds values that are created via getters from inner,
  such as with span in List


- remove _elements from Lists


- parameters are to be treated as a virtual copy!!
- instead of multiple layers of proxies, change the barrierRules as necessary

transport

https://www.slideshare.net/lizza919/types-of-movement-across-the-cell-membrane





- Streams


- consider switching to using explicit asMutable instead of immutability barrier in List
- make copying use the same method object tricks as equality uses to avoid expensive bookkeeping actions until necessary

- make global Copy and BeImmutable functions handle id
- consider other copy methods for Lists
- figure a faster way than using AsArray. Add length to Lists

- make comparators consider id in their comparisons of objects.





==
Make copy method work for types





==
Test Permeability

==
Add NameRec/Kname and Context



==
Add markdown to jsdoc - http://usejsdoc.org/plugins-markdown.html



/**
 * On instantiation, a blank virgin object has its implementation plumbing
 * connected.
 * @private
 * @typedef     Something
 * @property    {boolean} IS_IMMUTABLE
 * @property    {?identifier}       id
 * @property    {Proxy}       $
 */ $ _super

==

Consider not overloading Methods for special set_loader properties

use type of

method      ==> InstallMethod
onSetLoader ==> InstallSetLoader
onSetError  ==>
onSetMapper ==> InstallMappedProperty

==
Determine if it is allowable to assign undefined to a property to delete it

==
Ensure immutable and super porosity work on the type thingies

==
Make _super work on instances own methods




==
Add permanent methods distinction/protections

Figure out how to safely make types immutable. Can make entire
$root$inner/$root$outer frosted, becuase then properties such as constructor
cannot be overridden by subtypes.  Might need to do it method by method.


==
Consider using an AsLazyProperty maker instead of a dedicated set of lazy
wrappers.



--
 made ImmutableInner a lazy instantiated process from calling set on
original MutableInner once object has become immutable.

--
Perhaps do IS_IMMUTABLE like we did $KNOWN_PROPERTIES


===

Test Type as immutable and copying

==



test about permeable isInner vs isOuter vs $SECRET

Make a test where an immutable object is about to set a new property value to
itself, but first calls an assigner, that changes another property first.
Make sure it behaves properly!!!

Test other methods that call InSetProperty, for when they set a property to self

Write a test that shows symbols arent copied

Test about _unknownProperty when the property is a symbols

Make Context be func object like Type

In TypeOuter and TypeInner, pass in isPermeable instead of actually Permeability

Test that barrier unchanged when setting to mutable, but once immutable, the
same barrier is changed

Test to show each object has its own barrier

Test to show barrier is unchanged when setting mutable object

Add jasmineToString property







==
  change property to selector in most places
  property
    selector name|symbol
    value

==


==
Create an option for unknownProperty to return undefined??? or null





Check $OUTER_WRAPPER

==

Think about how to manage $Intrinsic type NOT being copied!


Symbols are known but not visible


==
Consider putting declaration as null in $IMMEDIATES

==
addGetter
add reader assigner error

Is there any real difference between retro and lazy?

==
Immutables on Set doesnt work!!!

==
fix addDurables -- make it a Definition

Add tests re: _DURABLES for InSetProperty

Test to ensure _DURABLES are retroactively added to immutables

==
Simplify AsRetroactiveProperty and AsLazyProperty


==
Change root vars to use _$ style naming too

==
Consider using name computed vs immediate (Not likely)

==
change NewDisguisedInner and porosity to have separate barrier (classes)
for Contexts and Types, so Contexts can have their own get method.

==
const firstChar = (selector.charAt) ? selector[0] : selector.toString()[SYMBOL_1ST_CHAR]
Add an implementation selector stash


==
Write tests for checking setId on Immutable.


==
Check if we still need AddPermeableNewDefinitionTo
(At least rename to OverrideNewDefinition)
Check _newBlank
Check calls to BePermeable with $IS_IMPENETRABLE


Check this:
if (useNewContext && marked[COUNT]) {
      MarkDependentTypes    (execContext, marked)
      InPutCopyForEachMarked(execContext, sourceEntries, marked, visited)
    }

==
Add subcontexts methods to Context

==
Consider

  list._1
  list._atPut(1)

==
  addGetter ???

==
Collections

// value elements
HandAxe.Array
HandAxe.Set
HandAxe.Map

// fact elements
HandAxe.List
HandAxe.Dict
HandAxe.AssociativeList



==

addBothValueMethods(function copy_())
addBothValueMethods(function copy$())

addBothMethods
addBothValueMethods
addBothSelfMethods

==
Add a visibility property to definition
so that copying of invisible definitions actually works

==
Consider using this naming convention for permeables

.new$()
._initFrom$()

execContext (Dog, $Dog, _Dog, Dog$)
// current, inherited, mutable, permeable

==
Add HandAxe.AsString <-- for debugging 'something' objects


==
Add
- allDefinitionTags
- forEachDefinitions

- enum

==
In types, change _blanker to $INSTANCE_BLANKER

==
Check when using addSharedProperty to add a func 

==========

ikigai
ponzu
enjoyment
ObjectSauce|Tranya
osauce
HandAxe


// var ParenthesesMatcher   = /\(|\)/
// var SelectorMatcher      = /[\w\$_!&]+/gi
const VowelMatcher         = /^[aeiou]/i
const ValidSelectorMatcher = /_*\$*[a-z][\w$]*/





addDurableProperties
  addDeclarations


addDeclaration
        _properties[propertyName] = KWO

        $KNOWN




standard
FACT_METHOD, VALUE_METHOD, BASIC_VALUE_METHOD, BASIC_SELF_METHOD, STANDARD_METHOD

        $root$inner[propertyName] = $method.inner
        $root$outer[propertyName] = $method.outer
        _properties[propertyName] = method

immediate
  this.addMethod(propertyName, assigner)

  addRetroactiveProperty
    STANDARD_METHOD, BASIC_VALUE_METHOD
  addLazyProperty

        $root$inner[propertyName] = undefined
        $root$outer[propertyName] = undefined
        $root$inner[$IMMEDIATES][propertyName] = $method
        $root$outer[$IMMEDIATES][propertyName] = $method.outer
        _properties[propertyName] = method



assigner
  this.addDeclaration(propertyName)
  this.addMethod(propertyName, assigner, SET_LOADER)

        $root$inner[propertyName] = null
        $root$outer[propertyName] = null
        $root$inner[$SET_LOADERS][propertyName] = assigner

        _properties[propertyName] = method-set-loader...KNOWN
        // propertyName SHOULD BE READABLE

ASSIGNER


setter
  this.addDeclaration(propertyName)
  this.addMethod(setterName, setter)


        $root$inner[propertyName] = null
        $root$outer[propertyName] = null
        $root$inner[setterName] = $method-setter
        $root$outer[setterName] = $method-setter.outer

        _properties[propertyName] = null..KNOWN
        _properties[setterName] = method
        // propertyName SHOULD BE READABLE

SETTER, propertyName


mandatory
this.addDeclaration(propertyName)
this.addMethod(setterName, setter)
this.addMethod(propertyName, errorOnSet  , SET_LOADER)
this.addMethod(mappedSymbol, propertyName, SET_LOADER)

        $root$inner[propertyName] = null
        $root$outer[propertyName] = null
        $root$inner[setterName] = $method-setter
        $root$outer[setterName] = $method-setter.outer
        $root$inner[$SET_LOADERS][propertyName] = errorOnSet
        $root$inner[$SET_LOADERS][mappedSymbol] = propertyName

        _properties[propertyName] = method-errorOnSet
        _properties[setterName] = method-setter
        _properties[mappedSymbol] = method-mapped
        // propertyName SHOULD BE READABLE

setter w assigner
this.addDeclaration(propertyName)
this.addMethod(setterName, setter)
this.addMethod(propertyName, loader      , SET_LOADER)

        $root$inner[propertyName] = null
        $root$outer[propertyName] = null
        $root$inner[setterName] = $method-setter
        $root$outer[setterName] = $method-setter.outer

        $root$inner[$SET_LOADERS][propertyName] = loader

        _properties[propertyName] = method-loader
        _properties[setterName] = method-setter
        // propertyName SHOULD BE READABLE
