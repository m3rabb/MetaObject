- using proxies for meta-programming. the challenges of using proxies for privacy and also enabling shared (inherited) properties.
- challenges of enabling proxies for properties vs just methods.

- how Chrome determines the class type of an obj, and how unfortunately it doesnt handle proxies :-(

- testing (I hate tests, I love tests)
- immutability

frost/frozen/fact/immutable/constant



// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze

// To be a constant object, the entire reference graph
// (direct and indirect references to other objects)
// must reference only immutable frozen objects.
// The object being frozen is said to be immutable because the
// entire object state (values and references to other objects)
// within the whole object is fixed.  Note that strings, numbers,
// and booleans are always immutable and that Functions and Arrays
// are objects.


- to freeze or not
https://news.ycombinator.com/item?id=4415981
https://jsperf.com/freeze-vs-seal-vs-normal/3
https://jsperf.com/object-freeze
https://www.npmjs.com/package/icepick


- When to use symbols vs private properties


===


PrivateChars = SpawnFrom(null)

PrivateChars = {
  __proto__ : null,
  "_" : true,
  undefined : true
}

vs

const firstChar = selector[0]
const isPublic  = (firstChar !== "_" && firstChar !== undefined)

vs

switch


==

_ratify
_approve
_certify
_confirm
_validate
_finalNew
_confirmed
_certified
_postCreation
_postInit


==
function _set(prop, value)

to enable quick reading of properties but controlled setting
addSetter($IID, function id(newId) {
  return newId
}) {
  this._.id
}

Type.addSetter(function id(newId) {
  const existingId = this.id

  return value
})

==

$pulp[selector](...args)
vs
$inner[selector].apply($pulp, args)
vs
Apply($inner[selector], $pulp, args)

wrapper func vs proxy apply

==
Talk about big leap away from using an internal (mutable) proxy and using
property setter methods instead


==
class doesn't protect again skylight. Gotta do it the old fashion way
// Protect from prototype chain hacking!!! aka skylighting




===

Naming functions to work in debugger


// const FuncGlobals = {
//   $SECRET                : $SECRET,
//   $RIND                  : $RIND,
//   $PULP                  : $PULP,
//   $INNER                 : $INNER,
//   $BARRIER               : $BARRIER,
//   IS_IMMUTABLE           : IS_IMMUTABLE,
//   InterMap               : InterMap,
//   ImmutableInner         : ImmutableInner,
//   Copy                   : Copy,
//   CopyObject             : CopyObject,
//   DefineProperty         : DefineProperty,
//   InSetProperty          : InSetProperty,
//   InvisibleConfiguration : InvisibleConfiguration,
// }
//
// const FunctionNamer = new NamedFunctionMaker(FuncGlobals)




// UNTESTED
// function TameFunc(Func) {
//   const func = function $$$$$$safe(...args) {
//     const receiver =
//       (this != null && this[$SECRET] === $INNER) ? this[$RIND] : this
//     return Func.apply(receiver, args)
//   }
//
//   const vars  = {$$$$$: Func.name, Func: Func}
//   const named = FunctionNamer.make(vars, func)
//   return SetImmutableFunc(func)
// }


function NamedFunction(name, globals, functionSource) {
  const innerFunc = functionSource
  const funcBody = `
    return function (Globals) {
      return function ${name}(OriginalMethod) {
        let inner, porosity, receiver, result
        ...
        return (result === receiver) ? result.$ : result
      }
    }
  `
}


function MakeVacuousConstructor(name, freeze_) {
  const funcBody = `
    return function ${name}() {
      const message = "This constructor is only used for debugging!"
      return SignalError(${name}, message)
    }
  `
  const func = Function(funcBody)()
  return (freeze_ !== DONT_FREEZE) ?
    BeFrozenFunc(func) :
    DefineProperty(func, "name", InvisibleConfiguration)
}

function AsInnerFact(selector, Handler) {
  const func = function $$$$$_$innerFact(...args) {
    // this is $pulp
    const result = Handler.apply(this, args) // <<----------

    if (result === this)                               { return result }
    if (typeof result !== "object" || result === null) { return result }
    if (result[IS_IMMUTABLE] || result.id != null)     { return result }
    return ((result$inner = InterMap.get(result))) ?
      result$inner[$COPY](true).$ : CopyObject(result, true)
  }

  const named = FunctionNamer.make({$$$$$: selector, Handler: Handler}, func)
  return BeFrozenFunc(named)
}

function AsInnerFact(selector, Handler) {
  const name = `${selector}_$innerXYZFact`
  const func = {
    [name] : function XYZYX(...args) {
      // this is $pulp
      const result = Handler.apply(this, args) // <<----------

      if (result === this)                               { return result }
      if (typeof result !== "object" || result === null) { return result }
      if (result[IS_IMMUTABLE] || result.id != null)     { return result }
      return ((result$inner = InterMap.get(result))) ?
        result$inner[$COPY](true).$ : CopyObject(result, true)
    }
  }[name]

  // const named = FunctionNamer.make({$$$$$: selector, Handler: Handler}, func)
  return BeFrozenFunc(func)
}





// function MakeVacuousConstructor(name) {
//   const funcBody = `
//     return function ${name}() {
//       const message = "This constructor is only used for naming!"
//       return SignalError(${name}, message)
//     }
//   `
//   const func = Function(funcBody)()
//   Frost(func.prototype)
//   return DefineProperty(func, "name", InvisibleConfiguration)
// }




// function AsPublicMethod(originalFunc) {
//   const methodName = originalFunc.name
//   const funcBody   = `
//     return function (
//       InterMap, SetImmutable, ImmutableInnerPermeability,
//       INNER, IS_IMMUTABLE, INNER_PERMEABILITY
//     ) {
//       return function ${methodName}(OriginalMethod) {
//         let core, permeability, receiver, result
//
//         core = InterMap.get(this)
//
//         if ((permeability = core[INNER_PERMEABILITY])) {
//           if (permeability.inUse) {
//             permeability = new ImmutableInnerPermeability(core)
//           }
//           permeability.inUse = true
//           receiver = permeability.target
//         }
//         else { receiver = core[INNER] }
//
//         result = OriginalFunc.apply(receiver, args)
//
//         if (permeability) { // indicator that receiver isImmutable
//           if (result === receiver) {
//             result = permeability.target
//             if (result !== inner) {
//               permeability.target = permeability.inner  // reset permeability
//               result.beImmutable
//             }
//             permeability.inUse = false
//             return result.$
//           }
//           if (typeof value !== "object" || value === null) { return result }
//           if (value[IS_IMMUTABLE] || value.id != null)     { return result }
//           return ((valueCore = InterMap.get(value))) ?
//             valueCore[COPY](true).$ : CopyObject(value, true)
//         }
//
//         return (result === receiver) ? result.$ : result
//       }
//     }
//   `
//   const methodMaker  = Function(funcBody)
//   const publicMethod = methodMaker(
//     InterMap, SetImmutable, ImmutableInnerPermeability,
//     INNER, IS_IMMUTABLE, INNER_PERMEABILITY
//   )
//   publicMethod[IS_IMMUTABLE] = true
//   SetImmutable(publicMethod.prototype)
//   return SetImmutable(publicMethod)
// }




//
// function CreateInnerPublicMethod(methodName) {
//   const funcBody = `return function (globals) {
//     const
//       InterMap = globals.InterMap,
//       IMMUTABLE_WRITE_PERMEABILITY = globals.IMMUTABLE_WRITE_PERMEABILITY,
//       ImmutableWritePermeability   = globals.ImmutableWritePermeability,
//       AsOutsideFunc                = globals.AsOutsideFunc,
//       SECRET                       = globals.SECRET,
//       PARAM                        = globals.PARAM,
//       PARAM_TYPE                   = globals.PARAM_TYPE,
//       OBJECT                       = globals.OBJECT,
//       FACT                         = globals.FACT,
//       OUTSIDER                     = globals.OUTSIDER,
//       INNER                        = globals.INNER,
//       COPY                         = globals.COPY,
//       OUTER_BARRIER                = globals.OUTER_BARRIER,
//       InnerParamBarrier            = globals.InnerParamBarrier,
//       OuterParamBarrier            = globals.OuterParamBarrier,
//       ObjectParamBarrier           = globals.ObjectParamBarrier,
//       CopyObject                   = globals.CopyObject
//   ) {
//     return function ${methodName}(OriginalMethod) {
//
//     }
//   }`
//
//   const method = Function(funcBody)()
//   delete method.prototype
//   method.isFact = method.isImmutable = true
//   return SetImmutable(method)
// }




function MakeVacuousConstructor(name) {
  const func = {
    [name] : function () {
      const message = "This constructor is only used for naming!"
      return SignalError(name, message)
    }
  }[name]

  Frost(func.prototype)
  return DefineProperty(func, "name", InvisibleConfiguration)
}

==
This one doesn't work as expected

function AsInnerFact(selector, Handler) {
  const name = `${AsFunctionName(selector)}_$innerFact`
  const $innerFact = {}
  $innerFact[selector] = function (...args) {
    // this is $pulp
    const result = Handler.apply(this, args) // <<----------

    if (result === this)                               { return result }
    if (typeof result !== "object" || result === null) { return result }
    if (result[IS_IMMUTABLE] || result.id != null)     { return result }
    return ((result$inner = InterMap.get(result))) ?
      result$inner[$COPY](true).$ : CopyObject(result, true)
  }
  return BeFrozenFunc($innerFact[selector])
}
