<!DOCTYPE html>

<html>
<head>
  <title>top.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>top.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Written by Maurice Rabb - <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#109;&#114;&#64;&#x6d;&#x61;&#117;&#114;&#105;&#x63;&#101;&#114;&#97;&#x62;&#98;&#46;&#x63;&#111;&#109;">&#109;&#114;&#64;&#x6d;&#x61;&#117;&#114;&#105;&#x63;&#101;&#114;&#97;&#x62;&#98;&#46;&#x63;&#111;&#109;</a></p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Documentation by Tyler Camp - <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#116;&#x79;&#x6c;&#101;&#114;&#46;&#x63;&#x61;&#109;&#112;&#x40;&#x6c;&#x6f;&#111;&#x70;&#46;&#x63;&#x6f;&#108;&#117;&#109;&#46;&#101;&#100;&#x75;">&#116;&#x79;&#x6c;&#101;&#114;&#46;&#x63;&#x61;&#109;&#112;&#x40;&#x6c;&#x6f;&#111;&#x70;&#46;&#x63;&#x6f;&#108;&#117;&#109;&#46;&#101;&#100;&#x75;</a></p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2>Intro</h2>
<p> Top promotes a modified understanding of JavaScript‘s prototypical inheritance model. JS object programming is
 instead introduced in the form of Constructors, Roots, and Instances. Overall, constructors create instances
 from the instance root (prototype) that they maintain internally. A constructor has two types of roots - its own
 ’constructor‘ root, and the root that is used to create an instance when it is invoked with ’new&#39;. The
 instance root can be modified to expand the instances created by the constructor.</p>
<p> Top also provides architectural design tools, based on the Top object model, for creating ‘modules’. These provide
 you with methods for creating new types, which are invoked via i.e.: <code>new Top.MyModule.SomeType(...)</code>.</p>
<p> Many functions and tools are provided to create natural separation and organization of your code, all the while
 maintaining expressivity in the API. If JavaScript has good parts, then code architecting does too. Top attempts
 to keep you in the good parts by giving more expressive ways to define your architecture and excluding features
 that commonly lead to code smell.</p>
<p> Top also provides various convenience functions, such as:</p>
<ul>
<li>Automated accessors</li>
<li>GUID utilities</li>
<li>Simplified error reporting</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="string">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h2>Architectural Tools</h2>
<p>Sets up the functions used for manipulating/generating the Top object model.</p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Low-level JavaScript Object Manipulation</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="keyword">var</span> RootOf, SpawnFrom, Constructor_PassInstanceRootIntoMethod;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Instantiates a new Top Constructor, boostrapping the ‘init’ function to be called upon object instantiation.
 Helper function, only used by function <code>NewConstructor()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">CreateConstructor</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">aTopObject</span><span class="params">(SpecOrArgs)</span> {</span>
            <span class="keyword">var</span> init, args;
            <span class="comment">/* Prevent the use of a Constructor without instantiation of an object (a good rule and
             *  prevention of a common pitfall)
             */</span>
            <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">undefined</span>) {
                Top.signalError(aTopObject.Selector + <span class="string">" constructor called without new!"</span>);
                <span class="keyword">return</span> <span class="literal">null</span>;
            }
            init = <span class="keyword">this</span>.init;
            args = (<span class="keyword">typeof</span> SpecOrArgs === <span class="string">"object"</span> &amp;&amp; RootOf(SpecOrArgs) === OBJECT_ROOT) ?
                init.ParameterSelectors.map(<span class="function"><span class="keyword">function</span> <span class="params">(selector)</span> {</span> <span class="keyword">return</span> SpecOrArgs[selector]; }) :
                arguments;
            init.apply(<span class="keyword">this</span>, args);
        };
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p> Creates a new Top object constructor and configures it with the given properties.
 Every constructor gets a passInstanceRootInto method, which is used to expand the root
 of the instances that the constructor will generate. This method is added both to
 all Top constructors and all Top objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">NewConstructor</span><span class="params">(selector, parentConstructor)</span> {</span>
        <span class="keyword">var</span> parentRoot, constructor, root;
        parentRoot = parentConstructor.prototype;

        constructor = CreateConstructor();
        constructor.Selector = selector;
        constructor.ParentConstructor = parentConstructor;

        <span class="comment">/* Bootstrapping of passInstanceRootInto */</span>
        constructor.passInstanceRootInto = Constructor_PassInstanceRootIntoMethod;

        root = SpawnFrom(parentRoot);
        root.constructor = constructor;

        constructor.prototype = root;
        <span class="keyword">return</span> constructor;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p> <code>Yourself()</code> is used in TopObject.addMethod as a default init() function when the current instance root
     doesn&#39;t have a parent init. Defined in Top-global scope for reuse.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Yourself</span><span class="params">()</span> {</span> <span class="keyword">return</span> <span class="keyword">this</span>; }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Takes the selector string and returns a transformed version of the string, as would be appropriate for
 marking a selector private. The current implementation simply prefixes an &#39;_&#39; to denote private selectors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">AsPrivateProperty</span><span class="params">(selector)</span> {</span>
        <span class="keyword">var</span> firstChar = selector[<span class="number">0</span>];
        <span class="keyword">return</span> (firstChar === <span class="string">"_"</span>) ? selector : <span class="string">"_"</span> + firstChar.toUpperCase() + selector.slice(<span class="number">1</span>);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><code>RootOf()</code> obtains the root of the specified object; its implementation as getPrototypeOf is based on how
 the ‘root’ of any object is its prototype.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	RootOf = Object.getPrototypeOf;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p><code>SpawnFrom()</code> instantiates an object using the <em>root</em> that is passed to it. Bootstrapped into <code>Top</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	SpawnFrom = Object.create;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p> <code>passInstanceRootInto()</code> is a public-facing API that is accessible within all Top-created constructors. The
     function is bootstrapped to new constructors during the creation process in function <code>NewConstructor()</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Constructor_PassInstanceRootIntoMethod = <span class="function"><span class="keyword">function</span> <span class="title">passInstanceRootInto</span><span class="params">(rootExtensionAction)</span> {</span>
        rootExtensionAction &amp;&amp; rootExtensionAction.call(<span class="keyword">this</span>, <span class="keyword">this</span>.prototype);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h3>Accessor Generation Tools</h3>
<p>Top provides a variety of utilities for automatic generation of getter/setter functions. Putting aside JS
 native getters/setters (performance, compatibility), a getter/setter is a single normal function within
 an object. An accessor is a single behavior that acts as both a setter and a getter.</p>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>These internal functions are bootstrapped into TopObject later on.</p>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Creates an accessor that is mapped to an existing internal property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">CreateInstanceVarAccessor</span><span class="params">(selector, privatePropertyName)</span> {</span>
        <span class="keyword">var</span> accessor = <span class="function"><span class="keyword">function</span> <span class="title">anInstanceVarAccessor</span><span class="params">(value_)</span> {</span>
            <span class="keyword">return</span> arguments.length ?
                (<span class="keyword">this</span>[privatePropertyName] = value_, <span class="keyword">this</span>) : <span class="keyword">this</span>[privatePropertyName];
        };
        accessor.Selector = selector;
        <span class="keyword">return</span> accessor;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>A Custom accessor allows you to provide your own setter/getter functions if you want to customize a
getter/setter behavior. Bootstrapped into TopObject as <code>TODO: FILL</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">CreateCustomVarAccessor</span><span class="params">(selector, setter, getter)</span> {</span>
        <span class="keyword">var</span> accessor = <span class="function"><span class="keyword">function</span> <span class="title">aCustomVarAccessor</span><span class="params">(value_)</span> {</span>
            <span class="keyword">if</span> (value_ === <span class="literal">undefined</span>) {
                <span class="keyword">if</span> (getter !== <span class="literal">undefined</span> &amp;&amp; getter !== <span class="literal">null</span>)
                    <span class="keyword">return</span> getter.call(<span class="keyword">this</span>);
                <span class="keyword">else</span> {
                    <span class="keyword">if</span> (<span class="keyword">this</span> !== <span class="literal">undefined</span>)
                        <span class="keyword">this</span>.signalError(<span class="string">"Attempted to access getter for '"</span> + selector + <span class="string">"' but no getter was defined"</span>);
                }
            }
            <span class="keyword">else</span> {
                <span class="keyword">if</span> (setter !== <span class="literal">undefined</span> &amp;&amp; setter !== <span class="literal">null</span>)
                    setter.call(<span class="keyword">this</span>, value_);
                <span class="keyword">else</span> {
                    <span class="keyword">if</span> (<span class="keyword">this</span> !== <span class="literal">undefined</span>)
                        <span class="keyword">this</span>.signalError(<span class="string">"Attempted to access setter for '"</span> + selector + <span class="string">"' but no setter was defined"</span>);
                }

                <span class="keyword">return</span> <span class="keyword">this</span>;
            }
        };
        accessor.Selector = selector;
        <span class="keyword">return</span> accessor;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>A closured accessor is used for maintaining a value that does not exist in the object that the accessor
 is bound to. The accessor does not map to an internal value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">CreateClosuredAccessor</span><span class="params">(selector, persistentValue)</span> {</span>
        <span class="keyword">var</span> accessor = <span class="function"><span class="keyword">function</span> <span class="title">aClosuredVarAccessor</span><span class="params">(value_)</span> {</span>
            <span class="keyword">return</span> arguments.length ? (persistentValue = value_, <span class="keyword">this</span>) : persistentValue;
        };
        accessor.Selector = selector;
        <span class="keyword">return</span> accessor;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>A getter is called without any parameters to return an internal value. This value is assigned by
 calling the getter with the value as a parameter. The getter can&#39;t be called in that fashion again after the
 first assignment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">CreateGetter</span><span class="params">(selector, privatePropertyName)</span> {</span>
        <span class="keyword">var</span> getter = <span class="function"><span class="keyword">function</span> <span class="title">anInstanceVarWriteOneGetter</span><span class="params">(oneTimeInitializationValue_)</span> {</span>
            <span class="keyword">if</span> ( !arguments.length ) { <span class="keyword">return</span> <span class="keyword">this</span>[privatePropertyName]; }
            <span class="keyword">if</span> (<span class="keyword">this</span>.hasOwnProperty(privatePropertyName)) {
                <span class="keyword">this</span>.signalError(<span class="string">"Getter property can only be used as a setter once!"</span>);
            } <span class="keyword">else</span> {
                <span class="keyword">this</span>[privatePropertyName] = oneTimeInitializationValue_;
            }
            <span class="keyword">return</span> <span class="keyword">this</span>;
        };
        getter.Selector = selector;
        <span class="keyword">return</span> getter;
    }

    <span class="keyword">var</span> ACCESSOR_GETTER = <span class="number">1</span>, ACCESSOR_SETTER = <span class="number">2</span>, ACCESSOR_NOT_FUNCTION = <span class="number">3</span>, ACCESSOR_UNKNOWN = -<span class="number">1</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">GetAccessorType</span><span class="params">(accessorFunction)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> (accessorFunction) != <span class="string">'function'</span>)
            <span class="keyword">return</span> ACCESSOR_NOT_FUNCTION;

        <span class="keyword">switch</span> (accessorFunction.length) {
            <span class="keyword">case</span> (<span class="number">0</span>): <span class="keyword">return</span> ACCESSOR_GETTER;
            <span class="keyword">case</span> (<span class="number">1</span>): <span class="keyword">return</span> ACCESSOR_SETTER;
            <span class="keyword">default</span>: <span class="keyword">return</span> ACCESSOR_UNKNOWN;
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2>Utility Methods</h2>

            </div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h5>Object-Selector Bridging</h5>
<p> Various functions for extracting relevant data from JavaScript objects/functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="comment">/*  TODO: Double-check this documentation */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p> Extracts the parameters of the given function and returns an array of strings that represents the
     names of each parameter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">ExtractParametersAsSelectors</span><span class="params">(func)</span> {</span>
        <span class="keyword">var</span> source, parametersString, parameterNames;
        source = func.toString();
        parametersString = source.split(<span class="regexp">/\(|\)/</span>)[<span class="number">1</span>];
        parameterNames = AsSelectorList(parametersString);
        <span class="keyword">return</span> parameterNames.map(<span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
            <span class="keyword">var</span> selector, firstChar;
            selector = name.match(<span class="regexp">/([a-z0-9$_]+)?[a-z0-9$]/i</span>)[<span class="number">0</span>];
            firstChar = selector[<span class="number">0</span>];
            <span class="keyword">return</span> firstChar.toLowerCase() + selector.slice(<span class="number">1</span>);
        });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><code>AsSelectorList</code> extracts whitespace-separated words from the given string, effectively returning an
 array of strings that are suitable for being selectors. String arrays are simply returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="comment">/* TODO: Some parsing should be done to verify that the strings in an array input are suitable as selectors */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">AsSelectorList</span><span class="params">(stringOrStringArray)</span> {</span>
        <span class="keyword">return</span> (<span class="keyword">typeof</span> stringOrStringArray === <span class="string">"string"</span>) ?
            (stringOrStringArray.match(<span class="regexp">/[\w\$!]+/gi</span>) || []) : stringOrStringArray;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p> Calls the given action on all properties in the specifier for the given target. ‘this’ is bound
     to the object being iterated over.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="comment">/* TODO: OnSpecDo should be updated to pass the target as a parameter instead of binding as 'this' */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">OnSpecDo</span><span class="params">(target, spec, action)</span> {</span>
        <span class="keyword">var</span> propertyName;
        <span class="keyword">for</span> (propertyName <span class="keyword">in</span> spec) {
            <span class="keyword">if</span> (spec.hasOwnProperty(propertyName)) {
                action.call(target, spec[propertyName], propertyName);
            }
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h4>Random Number Generation</h4>
<p> Primarily for convenience, this type of randomInt function is commonly needed throughout projects in general.
Indirection for bootstrapping.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    RandomIntMethod = <span class="function"><span class="keyword">function</span> <span class="title">randomInt</span><span class="params">(minInt_, maxInt)</span> {</span>
        <span class="keyword">var</span> min, max;
        <span class="keyword">if</span> (arguments.length &lt;= <span class="number">1</span>) {
            min = <span class="number">0</span>, max = minInt_;
        } <span class="keyword">else</span> {
            min = minInt_, max = maxInt;
        }
        <span class="keyword">return</span> Math.floor(Math.random() * (max - min + <span class="number">1</span>)) + min;
    };

    <span class="comment">/* NOTE TO MAURICE: I noticed that the Math_floor and Math_random methods weren't doing anything and have
     *  them left out for now. I'm not sure what their intent was; I replaced their 1 usage with direct calls.  */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h4>128-bit ID Generation Functions</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> ZERO_PADDING, MAX_UNIQUE_ID_LENGTH, RandomIntMethod, NewUniqueIdMethod;

    ZERO_PADDING = <span class="string">"0000000000000000"</span>;
	MAX_UNIQUE_ID_LENGTH = (+<span class="keyword">new</span> Date(<span class="string">"2067-09-29"</span>) * <span class="number">0xFFFFFFFFFFFF</span>).toString(<span class="number">36</span>).length;

	<span class="function"><span class="keyword">function</span> <span class="title">NewUniqueId</span><span class="params">(prefix, seedDate, seedValue)</span> {</span>
	    <span class="keyword">var</span> id = seedDate * seedValue;
	    id = id.toString(<span class="number">36</span>);   <span class="comment">//</span>
	    <span class="keyword">return</span> prefix + ZERO_PADDING.slice(<span class="number">0</span>, MAX_UNIQUE_ID_LENGTH - id.length) + id;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p> The API-facing generation function, separated out for testing purposes. Bootstrapped to Top.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	NewUniqueIdMethod = <span class="function"><span class="keyword">function</span> <span class="title">newUniqueId</span><span class="params">(prefix_)</span> {</span>
	    <span class="keyword">var</span> prefix = prefix_ || <span class="string">""</span>;
	    <span class="keyword">return</span> NewUniqueId(prefix, Date.now(), RandomIntMethod(<span class="number">0xFFFFFFFFFFFF</span>));
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h2>Base Object Types</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> TopObject, Module, OBJECT_ROOT;
    OBJECT_ROOT = Object.prototype;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h1>TopObject</h1>
<p>Any object instantiated through Top inherits from TopObject. TopObject provides most root-level manipulation
 functionality, error reporting,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    TopObject = NewConstructor(<span class="string">"TopObject"</span>, Object);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>TopObject is a Constructor, and a Constructor maintains a root for the instances that it creates. This use
 of passInstanceRootInto shows that, when using the method, the instance root is passed as a parameter
 to the extension method, which is then expanded upon to define the root for instantiated objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	TopObject.passInstanceRootInto(<span class="function"><span class="keyword">function</span> <span class="params">(instanceRoot)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p> <code>TopObject.addMethod()</code> is a very commonly used method that is intended to be the way that a root is
     expanded. The given function is added to the instance root, and the function&#39;s name is used as
     the name of the new member.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod = <span class="function"><span class="keyword">function</span> <span class="title">addMethod</span><span class="params">(func)</span> {</span>
            <span class="keyword">if</span> (func === <span class="literal">undefined</span>)
                func = {};
			<span class="keyword">var</span> selector = func.name;
			func.Selector = selector;
			<span class="keyword">if</span> (selector === <span class="string">"init"</span>) {
				func.ParameterSelectors = ExtractParametersAsSelectors(func);
				func.ParentInit = RootOf(<span class="keyword">this</span>).init || Yourself;
			}
			<span class="keyword">this</span>[selector] = func;
			<span class="keyword">return</span> <span class="keyword">this</span>;
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Accessor methods whose general functionalities were previously outlined in the global scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">addGetter</span><span class="params">(selector)</span> {</span>
			<span class="keyword">var</span> propertyName = AsPrivateProperty(selector);
			<span class="keyword">this</span>[selector] = CreateGetter(selector, propertyName);
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">addAccessor</span><span class="params">(selector, closuredValue_)</span> {</span>
			<span class="keyword">var</span> propertyName;
			<span class="keyword">if</span> (arguments.length &lt; <span class="number">2</span>) {
				propertyName = AsPrivateProperty(selector);
				<span class="keyword">this</span>[selector] = CreateInstanceVarAccessor(selector, propertyName);
			} <span class="keyword">else</span> {
				<span class="keyword">this</span>[selector] = CreateClosuredAccessor(selector, closuredValue_);
			}
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p> Adds a list of accessors to the current TopObject. ‘selectors’ is a whitespace-separated string of selectors
 that will be used as the names of the generated accessors. Any accessor that ends in a &quot;!&quot; is interpreted as
     being getter-only.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">addAccessors</span><span class="params">(selectors)</span> {</span>
			<span class="keyword">var</span> selectorsList = AsSelectorList(selectors);
			selectorsList.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(selector)</span> {</span>
				<span class="keyword">var</span> length = selector.length;
				<span class="keyword">if</span> (selector[length - <span class="number">1</span>] === <span class="string">"!"</span>) {
					<span class="keyword">this</span>.addGetter(selector.slice(<span class="number">0</span>, length - <span class="number">1</span>));
				} <span class="keyword">else</span> {
					<span class="keyword">this</span>.addAccessor(selector);
				}
			}, <span class="keyword">this</span>);
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p> When defining a custom accessor, you must define at least a setter or a getter. Ordering is arbitrary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">addCustomAccessor</span><span class="params">(selector, setterOrGetter1_, setterOrGetter2_)</span> {</span>
            <span class="keyword">var</span> getter = <span class="literal">null</span>, setter = <span class="literal">null</span>;
            <span class="keyword">var</span> firstType, secondType;
            firstType = GetAccessorType(setterOrGetter1_);
            secondType = GetAccessorType(setterOrGetter2_);

            <span class="keyword">switch</span> (firstType) {
                <span class="keyword">case</span> (ACCESSOR_GETTER): getter = setterOrGetter1_; <span class="keyword">break</span>;
                <span class="keyword">case</span> (ACCESSOR_SETTER): setter = setterOrGetter1_; <span class="keyword">break</span>;
                <span class="keyword">case</span> (ACCESSOR_UNKNOWN): <span class="keyword">this</span>.signalError(<span class="string">"Unable to deduce accessor type for first setterOrGetter"</span>);
            }

            <span class="keyword">switch</span> (secondType) {
                <span class="keyword">case</span> (ACCESSOR_GETTER): getter = setterOrGetter2_; <span class="keyword">break</span>;
                <span class="keyword">case</span> (ACCESSOR_SETTER): setter = setterOrGetter2_; <span class="keyword">break</span>;
                <span class="keyword">case</span> (ACCESSOR_UNKNOWN): <span class="keyword">this</span>.signalError(<span class="string">"Unable to deduce accessor type for second setterOrGetter"</span>);
            }

            <span class="keyword">this</span>[selector] = CreateCustomVarAccessor(selector, setter, getter);
            <span class="keyword">return</span> <span class="keyword">this</span>;
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><code>aliasMethod</code> provides a more expressive way to create method aliases than simple assignment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">aliasMethod</span><span class="params">(aliasSelector, originalSelector)</span> {</span>
			<span class="keyword">this</span>[aliasSelector] = <span class="keyword">this</span>[originalSelector];
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});

        instanceRoot.addAccessors(<span class="string">"id!"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p> <code>init</code> is the Top way of defining a constructor. In a subtype, simply create another <code>init</code> via
 <code>TopObject.addMethod</code>. Invoke <code>this.ParentInit.init(...)</code> to begin the constructor chain. <code>this</code> will
 be the <code>init</code> function that you&#39;ve defined, and <code>ParentInit</code> will be the <code>init</code> of the parent type.
 <code>ParentInit</code> is created under a special condition in <code>addMethod</code>, which is followed when adding a method
 with the name <code>init</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(id_)</span> {</span>
			<span class="keyword">var</span> prefix, id;
			prefix = <span class="keyword">this</span>.constructorName() + <span class="string">"-"</span>;
			id = (id_ === <span class="literal">undefined</span>) ? NewUniqueIdMethod(prefix) : <span class="string">""</span> + id_;
			<span class="keyword">this</span>.id(id); <span class="comment">// The unique resource id</span>
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p> Gets the root of the given TopObject.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">root</span><span class="params">()</span> {</span> <span class="keyword">return</span> RootOf(<span class="keyword">this</span>); });

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">constructorName</span><span class="params">()</span> {</span>
			<span class="keyword">return</span> <span class="keyword">this</span>.constructor.Selector;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p> <code>passInto</code> calls the extension action with the invokee as the parameter, and with the invokee bound
 as ‘this’. It is one of the core functions that encourages code segmentation. Generally used to expand upon
 an object, use of this function also helps prevent dependent data from leaking into outer scopes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">passInto</span><span class="params">(extensionAction)</span> {</span>
            extensionAction &amp;&amp; extensionAction.call(<span class="keyword">this</span>, <span class="keyword">this</span>);
            <span class="keyword">return</span> <span class="keyword">this</span>;
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p> <code>passRootInto</code> is the other segmentation function and is used to expand upon root objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">passRootInto</span><span class="params">(rootExtensionAction)</span> {</span>
			rootExtensionAction &amp;&amp; rootExtensionAction.call(<span class="keyword">this</span>, RootOf(<span class="keyword">this</span>));
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p> A setter/getter for the Top-determined name of this instance. If this property
 has not been specified by the user, the instance ID is returned by default.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">name</span><span class="params">(name_)</span> {</span>
			<span class="keyword">var</span> currentName;
			<span class="keyword">if</span> (arguments.length) { <span class="keyword">this</span>._Name = name_; <span class="keyword">return</span> <span class="keyword">this</span>; }
			currentName = <span class="keyword">this</span>._Name;
			<span class="keyword">return</span> (currentName === <span class="literal">undefined</span>) ? <span class="keyword">this</span>._Id : currentName;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p> Creates a human-readable string that identifies a specific Top object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">toString</span><span class="params">()</span> {</span>
			<span class="keyword">var</span> name = <span class="keyword">this</span>._Name;
			<span class="keyword">return</span> (name ? name + <span class="string">":"</span> : <span class="string">""</span>) + <span class="keyword">this</span>._Id;
		});

        <span class="comment">/* TODO: Not sure of what this is supposed to do? */</span>
        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">setEach</span><span class="params">(spec)</span> {</span>
			OnSpecDo(<span class="keyword">this</span>, spec, <span class="function"><span class="keyword">function</span> <span class="params">(value, setter)</span> {</span> <span class="keyword">this</span>[setter](value); });
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});

        <span class="comment">/* TODO: Handlers? */</span>
        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">handlers</span><span class="params">()</span> {</span>
			<span class="keyword">return</span> <span class="keyword">this</span>._Handlers || (<span class="keyword">this</span>._Handlers = Top.newStash());
		});

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">handlerFor</span><span class="params">(selector)</span> {</span>
		    <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers();
			<span class="keyword">return</span> handlers[selector] ||
				(handlers[selector] = Top.bind(<span class="keyword">this</span>, <span class="keyword">this</span>[selector]));
		});

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">removeHandlerFor</span><span class="params">(selector)</span> {</span>
			<span class="keyword">var</span> handlers, handler;
			<span class="keyword">if</span> ((handlers = <span class="keyword">this</span>._Handlers)) {
				handler = handlers[selector];
				handlers[selector] = <span class="literal">null</span>;
			}
			<span class="keyword">return</span> handler;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p> <code>signalError</code> is a simple method for allowing error reporting within a TopObject. Invocation is as
 simple as <code>this.signalError(&quot;Something went wrong&quot;);</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">signalError</span><span class="params">(message)</span> {</span>
			<span class="keyword">var</span> error;
			<span class="keyword">if</span> (Top.handleErrorsQuietly()) {
                console.warn(message);
                <span class="keyword">return</span> <span class="keyword">this</span>;
            }

            console.error(message);

			error = <span class="keyword">new</span> Error(message);
			error.name = <span class="keyword">this</span>.constructorName() + <span class="string">"-Error"</span>;
			error.target = <span class="keyword">this</span>;
			<span class="keyword">throw</span> error;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p> <code>notYetImplemented</code> and <code>notYetTested</code> are maintenance tools that output a debug message when invoked. They
 are available in every TopObject, so invocation is simply a matter of &#39;this.notYetImplemented<code>or</code>this.notYetTested`</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">notYetImplemented</span><span class="params">()</span> {</span>
			<span class="keyword">return</span> <span class="keyword">this</span>.signalError(<span class="string">"Method not yet implemented!"</span>);
		});

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">notYetTested</span><span class="params">()</span> {</span>
			<span class="keyword">return</span> <span class="keyword">this</span>.signalError(<span class="string">"Method not yet tested!"</span>);
		});

	});</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <h1>Module</h1>
<p>Modules are objects with the same functionality as a TopObject, but with the added ability to create types,
 subtypes, and submodules. Moving Type management into Modules allows us to create natural hierarchies
 and allows Top to automatically turn your types into TopObjects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Module = NewConstructor(<span class="string">"Module"</span>, TopObject);

	Module.passInstanceRootInto(<span class="function"><span class="keyword">function</span> <span class="params">(instanceRoot)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p> The Module constructor requires its name, and optionally, the parent object that will contain the
 module, and an extension action for expanding upon the module object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(name, parentContext_, extensionAction_)</span> {</span>
            <span class="comment">/* TODO: Document how the call chain for 'init' is processed */</span>
			<span class="keyword">var</span> parentContext, extensionAction;
			init.ParentInit.call(<span class="keyword">this</span>);

			<span class="keyword">if</span> (<span class="keyword">typeof</span> parentContext_ === <span class="string">"function"</span>) {
				extensionAction = parentContext_;
			} <span class="keyword">else</span> {
				parentContext = parentContext_;
				extensionAction = extensionAction_;
			}

			<span class="keyword">this</span>.parentContext(parentContext || <span class="literal">null</span>);
			<span class="keyword">this</span>.name(name || <span class="keyword">this</span>.id());
			<span class="keyword">return</span> <span class="keyword">this</span>.passInto(extensionAction);
		});

        instanceRoot.addAccessors(<span class="string">"parentContext!"</span>);

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">name</span><span class="params">(name_)</span> {</span>
			<span class="keyword">var</span> currentName, parentContext;
			currentName = <span class="keyword">this</span>._Name;
			<span class="keyword">if</span> (!arguments.length) { <span class="keyword">return</span> currentName; }
			parentContext = <span class="keyword">this</span>.parentContext();
			<span class="keyword">if</span> (parentContext) {
				<span class="keyword">if</span> (currentName !== <span class="literal">undefined</span>) { <span class="keyword">delete</span> parentContext[<span class="keyword">this</span>._Name]; }
				parentContext[name_] = <span class="keyword">this</span>;
			}
			<span class="keyword">this</span>._Name = name_;
			<span class="keyword">return</span> <span class="keyword">this</span>;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p> Creates and returns a new type, using the optional <code>rootExtensionAction_</code> parameter to expand upon
 the root for the newly-created type. New types are automatically subtyped from TopObject.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">newType</span><span class="params">(typeName, rootExtensionAction_)</span> {</span>
			<span class="keyword">return</span> <span class="keyword">this</span>.newSubTypeFrom(typeName, TopObject, rootExtensionAction_);
		});

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">newSubTypeFrom</span><span class="params">(typeName, parent, rootExtensionAction_)</span> {</span>
			<span class="keyword">var</span> parentConstructor, constructor;
			<span class="keyword">this</span>[typeName] &amp;&amp; <span class="keyword">this</span>.signalError(<span class="string">"Type already in module!"</span>);
			<span class="keyword">switch</span> (<span class="keyword">typeof</span> parent) {
				<span class="keyword">case</span> <span class="string">"function"</span> :
					parentConstructor = parent;
					<span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="string">"string"</span>   :</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>/ <strong>proto</strong> contains “Object” at this point, but for
/     some reason the member isn&#39;t being found</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					parentConstructor = <span class="keyword">this</span>[parent] ||
						<span class="keyword">this</span>.signalError(<span class="string">"Unknown parent constructor name!: "</span> + parent);
					<span class="keyword">break</span>;
				<span class="keyword">default</span> : <span class="keyword">this</span>.signalError(<span class="string">"Invalid parent argument!"</span>);
			}
			constructor = NewConstructor(typeName, parentConstructor);
			<span class="keyword">this</span>[typeName] = constructor;
			<span class="keyword">return</span> constructor.passInstanceRootInto(rootExtensionAction_);
		});

        instanceRoot.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">newSubModule</span><span class="params">(moduleName, extensionAction_)</span> {</span>
			<span class="keyword">var</span> module = SpawnFrom(<span class="keyword">this</span>);
			module.init(moduleName, <span class="keyword">this</span>);
			<span class="keyword">this</span>[moduleName] = module;
			<span class="keyword">return</span> module.passInto(extensionAction_);
		});
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h1>Top</h1>
<p> The global Top object/namespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	window.Top = <span class="keyword">new</span> Module(<span class="string">"Top"</span>, window, <span class="function"><span class="keyword">function</span> <span class="params">(module)</span> {</span>
		<span class="keyword">var</span> GUID_SEGMENTS, GUID_SEGMENTS_LENGTHS;</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p> The Top object exposes the Object and Module types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        module.Object = TopObject;
        module.Module = Module;

        module.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">bind</span><span class="params">(Target, Func)</span> {</span>
		    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">delegator</span><span class="params">(<span class="comment">/* arguments */</span>)</span> {</span>
		        <span class="keyword">return</span> Func.apply(Target, arguments);
		    };
		});

        module.addMethod(RandomIntMethod);

        module.addMethod(NewUniqueIdMethod);</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p> GUID generation methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		GUID_SEGMENTS_LENGTHS = [<span class="number">8</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>];
		GUID_SEGMENTS = [<span class="number">0xFFFFFFFF</span>, <span class="number">0xFFFF</span>, <span class="number">0xFFF</span>, <span class="number">0x3FFF</span>, <span class="number">0xFFFFFF</span>, <span class="number">0xFFFFFF</span>];
		GUID_SEGMENTS = GUID_SEGMENTS.map(<span class="function"><span class="keyword">function</span> <span class="params">(segment)</span> {</span> <span class="keyword">return</span> segment + <span class="number">1</span>; });

        module.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">isGUID</span><span class="params">(string)</span> {</span>
		    <span class="keyword">var</span> match;
		    <span class="keyword">if</span> (<span class="keyword">typeof</span> string !== <span class="string">"string"</span>) { <span class="keyword">return</span> <span class="literal">false</span>; }
		    match = string.match(<span class="regexp">/^[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/gi</span>);
		    <span class="keyword">return</span> (match !== <span class="literal">null</span>) &amp;&amp; (match.length === <span class="number">1</span>);
		});

        module.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">newGUID</span><span class="params">()</span> {</span>
			<span class="comment">/* This newGUID4 from http://jsperf.com/guid-makers/3
			 * http://en.wikipedia.org/wiki/Uuid#Version_4_.28random.29
			 * xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx    y -&gt; &amp; 0x3 | 0x8;
			 */</span>
			<span class="keyword">var</span> index, seedValues, substrings, grouping, padding;
			index = GUID_SEGMENTS.length;
			seedValues = [];
			<span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) {
				seedValues[index] = Math.floor(Math.random() * GUID_SEGMENTS[index]);
			}
			substrings = [];
		    seedValues[<span class="number">2</span>] += <span class="number">0x4000</span>;
		    seedValues[<span class="number">3</span>] += <span class="number">0x8000</span>;
			index = <span class="number">0</span>;
		    <span class="keyword">while</span> (index &lt; <span class="number">6</span>) {
		        grouping = seedValues[index].toString(<span class="number">16</span>);
		        padding = ZERO_PADDING.slice(<span class="number">0</span>, GUID_SEGMENTS_LENGTHS[index] - grouping.length);
		        substrings.push(padding, grouping);
		        <span class="keyword">if</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attribute">4</span>) { <span class="attribute">substrings.push</span>("<span class="attribute">-</span>"); }
		    }
		    <span class="attribute">return</span> <span class="attribute">substrings.join</span>("");
		});

		/* <span class="attribute">http:</span>//<span class="attribute">stackoverflow.com</span>/<span class="attribute">questions</span>/<span class="attribute">105034</span>/<span class="attribute">how-to-create-a-guid-uuid-in-javascript</span> */
		/* <span class="attribute">http:</span>//<span class="attribute">frugalcoder.us</span>/<span class="attribute">post</span>/<span class="attribute">2012</span>/<span class="attribute">01</span>/<span class="attribute">13</span>/<span class="attribute">javascript-guid-uuid-generator.aspx</span> */

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>        module.spawnFrom = SpawnFrom;

        module.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">newStash</span><span class="params">()</span> {</span> <span class="keyword">return</span> <span class="keyword">this</span>.spawnFrom(<span class="literal">null</span>); });

        module.addAccessor(<span class="string">"handleErrorsQuietly"</span>, <span class="literal">false</span>);

        module.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">isTopObject</span><span class="params">(target)</span> {</span>
			<span class="keyword">switch</span> (<span class="keyword">typeof</span> target) {
				<span class="keyword">case</span> <span class="string">"function"</span> : <span class="keyword">return</span> (target.passInstanceRootInto == Constructor_PassInstanceRootIntoMethod);
				<span class="keyword">case</span> <span class="string">"object"</span>   : <span class="keyword">return</span> (target <span class="keyword">instanceof</span> Top.Object);
			}
			<span class="keyword">return</span> <span class="literal">false</span>;
		});

        module.addMethod(<span class="function"><span class="keyword">function</span> <span class="title">asDate</span><span class="params">(dateValue_)</span> {</span>
			<span class="keyword">if</span> (dateValue_ <span class="keyword">instanceof</span> Date) { <span class="keyword">return</span> dateValue_; }
			<span class="keyword">switch</span> (<span class="keyword">typeof</span> dateValue_) {
				<span class="keyword">case</span> <span class="string">"undefined"</span> :
					<span class="keyword">return</span> <span class="keyword">new</span> Date();
				<span class="keyword">case</span> <span class="string">"string"</span> :
				<span class="keyword">case</span> <span class="string">"number"</span> :
					<span class="keyword">return</span> <span class="keyword">new</span> Date(dateValue_);
			}
			<span class="keyword">return</span> <span class="keyword">this</span>.signalError(<span class="string">"Argument cannot be converter to a date"</span>);
		});
	});
})();</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
